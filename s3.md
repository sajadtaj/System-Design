
 <div style="
     direction: rtl;
       text-align: justify;
         font-family: 'Vazirmatn', Tahoma, sans-serif;
           font-size: 16px;
             line-height: 2;
               color: #222;
                 background-color: #fdfdfd;
                   padding: 20px;
                     border-radius: 12px;
                       border: 1px solid #ddd;
                         text-align-last: right;
                           unicode-bidi: plaintext;
                           ">                         

---

### **مقدمه فصل سوم: ذخیره و بازیابی داده‌ها**

فصل سوم کتاب "طراحی برنامه‌های داده‌محور" به **موضوعات اساسی ذخیره‌سازی و بازیابی داده‌ها از دیدگاه پایگاه داده** می‌پردازد. در فصل دوم، ما مدل‌های داده‌ای و زبان‌های پرس‌وجو را بررسی کردیم؛ یعنی قالبی که شما (به‌عنوان توسعه‌دهنده برنامه) داده‌ها را به پایگاه داده می‌دهید و مکانیزمی که می‌توانید بعدها آن را درخواست کنید. این فصل، ادامه همان مبحث است، اما از **دیدگاه داخلی پایگاه داده**، توضیح می‌دهد که چگونه داده‌ها ذخیره می‌شوند و چگونه می‌توان آن‌ها را به صورت کارآمد بازیابی کرد. هدف اصلی این است که با درک مکانیسم‌های داخلی پایگاه‌های داده، بتوانیم ابزار مناسب را برای هر کار انتخاب کنیم و تصمیمات طراحی بهتری بگیریم.

---

### **موضوعات مهم فصل سوم: ذخیره و بازیابی داده‌ها (Chapter 3: Storage and Retrieval)**

این فصل به تفصیل ساختارهای داده‌ای که پایگاه‌های داده را تغذیه می‌کنند و همچنین تفاوت‌های بین سیستم‌های پردازش تراکنش (OLTP) و سیستم‌های تحلیل داده (OLAP) را بررسی می‌کند:

1.  **ساختارهای داده‌ای که پایگاه داده شما را تغذیه می‌کنند (Data Structures That Power Your Database)**
    *   **مثال اولیه یک فروشگاه کلید-مقدار (Simple Key-Value Store Example)**:
        کتاب با یک مثال ساده از یک سیستم ذخیره‌سازی کلید-مقدار (key-value store) بر پایه ابزارهای یونیکس (Unix) شروع می‌کند. در این مثال، داده‌ها به سادگی به انتهای یک فایل متنی (به‌عنوان یک "لاگ" یا گزارش) اضافه می‌شوند. تابع `db_set` یک جفت کلید-مقدار را به فایل اضافه می‌کند و تابع `db_get` آخرین مقدار مرتبط با یک کلید مشخص را با جستجو در فایل و گرفتن آخرین رخداد آن کلید پیدا می‌کند.
        این رویکرد، اگرچه بسیار ساده است، اما در افزودن داده‌ها به انتهای فایل (append-only) بسیار کارآمد عمل می‌کند. پایگاه‌های داده واقعی نیز از این ایده "لاگ" (log) به عنوان یک فایل داده فقط-الحاق (append-only data file) به صورت داخلی استفاده می‌کنند. البته پایگاه‌های داده واقعی باید با چالش‌هایی مانند کنترل همزمانی (concurrency control)، بازیابی فضای دیسک (reclaiming disk space) و مدیریت خطاها سروکار داشته باشند.

    *   **شاخص‌های هش (Hash Indexes)**:
        برای بهبود عملکرد `db_get` (بازیابی داده)، می‌توان از یک شاخص هش (hash index) استفاده کرد. در این رویکرد، یک نقشه هش در حافظه (in-memory hash map) نگهداری می‌شود که هر کلید را به موقعیت (offset) داده آن در فایل دیسک نگاشت می‌کند. زمانی که یک کلید به روز رسانی می‌شود، مقدار جدید به انتهای فایل اضافه شده و نقشه هش به موقعیت جدید اشاره می‌کند.
        *   **فشردگی (Compaction)**: برای جلوگیری از پر شدن دیسک به دلیل رویکرد فقط-الحاق (append-only)، فایل لاگ به بخش‌های کوچکتر (segments) تقسیم می‌شود. عملیات **فشردگی (compaction)** روی این بخش‌ها انجام می‌شود تا کلیدهای تکراری حذف شده و فقط آخرین به‌روزرسانی برای هر کلید حفظ شود. این عملیات به صورت پس‌زمینه اجرا می‌شود و فایل‌های بخش‌بندی شده را ترکیب می‌کند تا یک بخش فشرده‌تر و کوچک‌تر ایجاد شود.
            **شکل 3-2** فرآیند فشردگی یک لاگ به‌روزرسانی کلید-مقدار را نشان می‌دهد که فقط جدیدترین مقدار برای هر کلید را نگه می‌دارد. **شکل 3-3** عملیات فشردگی و ادغام بخش‌ها را به صورت همزمان نمایش می‌دهد.
        *   **حذف رکوردها (Deleting Records)**: برای حذف یک کلید، یک رکورد خاص به نام **"سنگ قبر" (tombstone)** به فایل داده اضافه می‌شود. در حین فشردگی، این سنگ قبر به فرآیند ادغام کننده می‌گوید که هر مقدار قبلی برای کلید حذف شده را کنار بگذارد.
        *   **بازیابی پس از خرابی (Crash Recovery)**: اگر پایگاه داده مجدداً راه‌اندازی شود، نقشه‌های هش در حافظه از بین می‌روند. می‌توان نقشه هش هر بخش را با خواندن کل فایل بخش از ابتدا تا انتها بازسازی کرد، اما این کار ممکن است زمان‌بر باشد.

    *   **SSTables و LSM-Trees (Log-Structured Merge-Trees)**:
        SSTables (Sorted String Tables) نسخه‌ای بهبود یافته از بخش‌های لاگ فشرده هستند. در این ساختار، جفت‌های کلید-مقدار بر اساس کلیدها به صورت مرتب ذخیره می‌شوند. این مرتب‌سازی باعث می‌شود که ادغام چندین SSTable (مانند ادغام فایل‌های مرتب‌سازی شده در Mergesort) بسیار کارآمد باشد.
        *   **نوشتن (Writing)**: وقتی یک نوشتن جدید انجام می‌شود، آن به یک درخت در حافظه (مانند B-tree یا Red-Black tree) به نام **Memtable** اضافه می‌شود. هنگامی که Memtable به اندازه معینی رسید، به صورت یک SSTable جدید به دیسک نوشته می‌شود. برای اطمینان از پایداری در صورت خرابی، قبل از نوشتن به Memtable، داده‌ها به یک لاگ **write-ahead log (WAL)** فقط-الحاق نیز نوشته می‌شوند.
        *   **خواندن (Reading)**: برای خواندن یک کلید، ابتدا Memtable بررسی می‌شود. اگر کلید در آنجا یافت نشد، SSTable های روی دیسک (که به صورت مرتب هستند) بررسی می‌شوند. این فرآیند می‌تواند شامل ادغام نتایج از چندین SSTable باشد.
        *   **مزایا**: LSM-trees برای حجم بالای عملیات نوشتن بهینه شده‌اند زیرا عمدتاً از نوشتن‌های ترتیبی (sequential writes) استفاده می‌کنند که روی دیسک‌ها بسیار کارآمد است.

    *   **B-Trees**:
        B-Trees رایج‌ترین ساختار داده شاخص‌گذاری در پایگاه‌های داده سنتی هستند. B-Tree ها داده‌ها را در بلوک‌های با اندازه ثابت (صفحات) سازماندهی می‌کنند که به صورت یک ساختار درختی با فَن‌اوت (fan-out) بالا مرتب شده‌اند.
        *   **خواندن (Reading)**: برای خواندن، پایگاه داده با دنبال کردن رفرنس‌ها (اشاره‌گرها) از ریشه درخت به سمت پایین، به صفحه‌ای که حاوی کلید مورد نظر است می‌رسد.
        *   **نوشتن (Writing)**: هنگام به‌روزرسانی یا درج، صفحه مربوطه در دیسک به‌روزرسانی می‌شود. اگر یک صفحه پر شود، تقسیم می‌شود و یک صفحه جدید ایجاد می‌شود که نیاز به به‌روزرسانی رفرنس‌های والد دارد.
        *   **قابلیت اطمینان (Reliability)**: B-Trees نیز از یک لاگ write-ahead (WAL) برای بازیابی پس از خرابی استفاده می‌کنند تا اطمینان حاصل شود که تغییرات قبل از نوشتن نهایی به دیسک، پایدار (durable) هستند.

    *   **مقایسه B-Trees و LSM-Trees**:
        *   **نوشتن (Writes)**: LSM-trees به طور کلی برای حجم بالای نوشتن کارآمدتر هستند زیرا رویکرد فقط-الحاق (append-only) دارند و نوشتن‌های ترتیبی (sequential writes) را به حداکثر می‌رسانند. B-trees معمولاً نیاز به نوشتن داده‌ها حداقل دو بار (یک بار به WAL و یک بار به صفحه درخت) دارند که می‌تواند سربار بیشتری داشته باشد.
        *   **خواند‌ن (Reads)**: B-trees دارای عملکرد خواندن پیش‌بینی‌پذیرتری هستند، به خصوص در **درصد‌های بالا (higher percentiles)**، زیرا هر کلید در یک مکان قطعی در درخت قرار دارد. LSM-trees ممکن است نیاز به بررسی چندین SSTable داشته باشند که می‌تواند در برخی موارد منجر به تأخیر بیشتر شود.
        *   **فشردگی (Compaction)**: در LSM-trees، عملیات فشردگی پس‌زمینه می‌تواند با عملیات نوشتن رقابت کرده و پهنای باند دیسک را مصرف کند، که ممکن است در حجم بالای نوشتن، عملکرد را تحت تأثیر قرار دهد.

    *   **سایر ساختارهای شاخص‌گذاری (Other Indexing Structures)**:
        *   **شاخص‌های خوشه‌ای (Clustered Indexes)**: داده‌ها به صورت مستقیم در ساختار شاخص (بر اساس کلید اصلی) ذخیره می‌شوند.
        *   **شاخص‌های ثانویه (Secondary Indexes)**: رایج در پایگاه‌های داده رابطه‌ای، که مقادیر یک فیلد غیر از کلید اصلی را به کلیدهای اصلی رکوردها نگاشت می‌کنند.
        *   **شاخص‌های چند-ستونی (Multi-column Indexes)**: شاخص‌هایی که روی چندین ستون ایجاد می‌شوند.
        *   **جستجوی تمام‌متنی (Full-text Search)** و **شاخص‌های فازی (Fuzzy Indexes)**: شاخص‌های تخصصی برای جستجو در متن، با ویژگی‌هایی مانند تطابق کلمات با املای مشابه یا مترادف.
        *   **پایگاه‌های داده درون-حافظه‌ای (In-Memory Databases)**: این پایگاه‌های داده، تمام یا بخش بزرگی از مجموعه داده فعال را در RAM نگهداری می‌کنند. مزیت اصلی آن‌ها نه صرفاً سرعت خواندن از دیسک، بلکه جلوگیری از سربار تبدیل ساختارهای داده‌ای درون-حافظه‌ای به قالبی که قابل نوشتن روی دیسک باشد، است.

2.  **پردازش تراکنش یا تحلیل داده؟ (Transaction Processing or Analytics?)**
    این بخش به تمایز مهم بین دو نوع اصلی کاربرد پایگاه داده می‌پردازد:
    *   **پردازش تراکنش آنلاین (OLTP - Online Transaction Processing)**:
        این سیستم‌ها برای **کاربردهای رو به روی کاربر (user-facing)** طراحی شده‌اند. ویژگی‌های اصلی آن‌ها شامل:
        *   **حجم بالای درخواست‌های کوچک و خاص (high volume of small requests)**.
        *   **تأخیر پایین (low latency)** برای هر درخواست.
        *   معمولاً **رکوردهای موجود را به‌روزرسانی می‌کنند (update existing records)**.
        *   **معمولاً روی یک رکورد یا تعداد کمی رکورد عمل می‌کنند (single record operations)**.
        *   مثال‌ها: وب‌سایت‌های تجارت الکترونیک، سیستم‌های بانکی، اپلیکیشن‌های موبایل.

    *   **پردازش تحلیلی آنلاین (OLAP - Online Analytic Processing)**:
        این سیستم‌ها برای **تحلیل داده‌های تاریخی (historical data analysis)** و **گزارش‌گیری (reporting)** طراحی شده‌اند و اغلب به عنوان **"انبار داده" (data warehouse)** شناخته می‌شوند. ویژگی‌های اصلی آن‌ها شامل:
        *   **تعداد کمتر پرس‌وجوها (fewer queries)**.
        *   هر پرس‌وجو **تعداد زیادی از رکوردها را می‌خواند (read large number of records)**.
        *   نتایج معمولاً **تجمیعی (aggregated results)** هستند (مثلاً جمع، میانگین، شمارش).
        *   پرس‌وجوها عمدتاً **فقط-خواندن (read-only)** هستند.
        *   مثال‌ها: گزارش فروش، تحلیل روند مشتری، هوش تجاری.

    *   **ذخیره‌سازی ستونی (Column-Oriented Storage)**:
        برای بهینه‌سازی عملکرد در بارهای کاری OLAP، سیستم‌های ذخیره‌سازی ستونی (column-oriented storage) توسعه یافته‌اند. در این رویکرد، به جای ذخیره تمام داده‌های یک ردیف در کنار هم (که در ذخیره‌سازی سطری رایج است)، **تمام مقادیر یک ستون خاص در کنار هم ذخیره می‌شوند**.
        *   **مزایا**:
            *   **کاهش I/O دیسک (Reduced Disk I/O)**: برای پرس‌وجوهای تحلیلی که فقط به زیرمجموعه‌ای از ستون‌ها نیاز دارند، فقط ستون‌های مورد نیاز از دیسک خوانده می‌شوند.
            *   **فشردگی بهتر (Better Compression)**: مقادیر در یک ستون اغلب دارای الگوی مشابهی هستند (مثلاً همه اعداد، همه رشته‌ها از یک نوع)، که امکان فشردگی بسیار کارآمدتر را فراهم می‌کند.
            *   **بهره‌وری بهتر Cache CPU (Better CPU Cache Utilization)**: به دلیل فشردگی و خواندن متوالی داده‌های یک ستون، داده‌ها به صورت کارآمدتری در حافظه Cache CPU قرار می‌گیرند.
        *   **معایب**: نوشتن داده‌ها معمولاً در سیستم‌های ستونی کندتر است.

    *   **ستاره‌ها و دانه برف‌ها: طرح‌واره‌ها برای تحلیل (Stars and Snowflakes: Schemas for Analytics)**:
        در انبارهای داده (data warehouses)، یک الگوی رایج برای طراحی طرح‌واره (schema) به نام **طرح‌واره ستاره‌ای (star schema)** یا **مدل‌سازی ابعادی (dimensional modeling)** وجود دارد.
        *   **جدول واقعیت (Fact Table)**: در مرکز طرح‌واره ستاره‌ای قرار دارد. هر ردیف در این جدول نشان‌دهنده یک رویداد خاص است (مثلاً یک خرید مشتری، یک بازدید صفحه وب). این جداول معمولاً بسیار بزرگ هستند.
        *   **جداول ابعادی (Dimension Tables)**: این جداول اطلاعات متنی مربوط به رویدادهای موجود در جدول واقعیت را فراهم می‌کنند. آن‌ها "چه کسی، چه چیزی، کجا، چه زمانی، چگونه، و چرا" یک رویداد را توصیف می‌کنند.
        **شکل 3-9** نمونه‌ای از طرح‌واره ستاره‌ای برای استفاده در یک انبار داده را نشان می‌دهد.

    *   **تجمیع: مکعب‌های داده و نماهای مادی‌شده (Aggregation: Data Cubes and Materialized Views)**:
        پرس‌وجوهای انبار داده اغلب شامل توابع تجمیعی (aggregate functions) مانند SUM، COUNT، AVG هستند. برای جلوگیری از محاسبه مجدد این تجمیع‌ها برای هر پرس‌وجو، می‌توان آن‌ها را پیش‌محاسبه و کش (cache) کرد.
        **نمای مادی‌شده (materialized view)** یک کپی واقعی از نتایج یک پرس‌وجو است که روی دیسک ذخیره شده است. این مفهوم برای **داده‌های مشتق‌شده (derived data)** بسیار مهم است. برخلاف یک نمای مجازی (virtual view) که فقط یک میانبر برای پرس‌وجو است، یک نمای مادی‌شده داده‌های خود را به صورت فیزیکی ذخیره می‌کند و نیاز به به‌روزرسانی دارد.

---

### **مفاهیم و نکات کلیدی که باید بدانیم**

*   **اهمیت لاگ‌ها**: لاگ‌های فقط-الحاق (append-only logs) یک مفهوم بنیادی و کارآمد در طراحی سیستم‌های داده‌محور هستند. آن‌ها نه تنها برای ذخیره‌سازی اولیه بلکه برای قابلیت اطمینان، بازیابی پس از خرابی و بازپخش داده‌ها (replaying) نیز حیاتی هستند.
*   **مبادله نوشتن و خواندن (Read/Write Trade-offs)**: ساختارهای شاخص‌گذاری مانند B-Trees و LSM-Trees هر کدام مزایا و معایب خود را در برابر حجم کاری خواندن و نوشتن دارند. B-Trees برای خواندن‌های پیش‌بینی‌پذیر و LSM-Trees برای نوشتن‌های با حجم بالا و پشت سر هم مناسب‌تر هستند.
*   **تفکیک OLTP و OLAP**: تشخیص تفاوت بین سیستم‌های پردازش تراکنش (OLTP) و سیستم‌های تحلیلی (OLAP) اساسی است، زیرا آن‌ها نیازمندی‌های کاملاً متفاوتی دارند و بهینه‌سازی‌های متفاوتی را می‌طلبند. این تفکیک منجر به معماری‌های پایگاه داده‌ای بسیار متفاوتی (مانند پایگاه‌های داده سطری در مقابل ستونی) می‌شود.
*   **اهمیت داده‌های مشتق‌شده (Derived Data)**: نماهای مادی‌شده (materialized views) و شاخص‌ها اشکال مختلفی از داده‌های مشتق‌شده هستند که با پردازش داده‌های اصلی ایجاد می‌شوند تا پرس‌وجوها را کارآمدتر کنند. این مفهوم در بخش سوم کتاب بیشتر توسعه می‌یابد.
*   **نقش فشردگی (Compaction)**: فشردگی نه تنها برای بازپس‌گیری فضای دیسک بلکه برای بهبود عملکرد خواندن و سازماندهی داده‌ها در ساختارهای لاگ-محور مانند LSM-Trees ضروری است.

---

### **ارتباط با فصل‌های قبلی**

*   **فصل 1 (Reliable, Scalable, and Maintainable Applications)**:
    *   **قابلیت اطمینان (Reliability)**: بحث در مورد لاگ‌های write-ahead (WAL) در B-Trees و LSM-Trees مستقیماً به مفهوم دوام (durability) در قابلیت اطمینان (Reliability) اشاره دارد. WAL تضمین می‌کند که حتی در صورت خرابی سیستم، داده‌ها از دست نروند. مفهوم "سنگ قبر" (tombstone) نیز به قابلیت اطمینان در حذف داده‌ها مربوط می‌شود.
    *   **مقیاس‌پذیری (Scalability)**: این فصل به بررسی ساختارهای داده‌ای می‌پردازد که برای مقابله با حجم داده و بار کاری افزایش یافته (افزایش مقیاس‌پذیری) طراحی شده‌اند. مقایسه B-Trees و LSM-Trees و بهینه‌سازی‌های آن‌ها برای بارهای کاری خاص، مانند بارهای کاری با حجم بالای نوشتن (LSM-Trees) یا خواندن پیش‌بینی‌پذیر (B-Trees)، نمونه‌هایی از راه‌حل‌های مقیاس‌پذیری هستند. مفهوم ذخیره‌سازی ستونی نیز یک بهینه‌سازی برای مقیاس‌پذیری تحلیلی است.
    *   **قابلیت نگهداری (Maintainability)**: ایده فشردگی (compaction) در LSM-Trees و مدیریت فضای دیسک، و همچنین ساختارهای داده‌ای که امکان بازیابی آسان‌تر پس از خرابی را فراهم می‌کنند، به قابلیت نگهداری سیستم کمک می‌کنند.

*   **فصل 2 (Data Models and Query Languages)**:
    *   **پیاده‌سازی مدل‌های داده‌ای**: فصل 3 دقیقاً به این موضوع می‌پردازد که چگونه مدل‌های داده‌ای مورد بحث در فصل 2 (مانند مدل رابطه‌ای و مدل سند) به صورت داخلی در پایگاه داده پیاده‌سازی می‌شوند. به عنوان مثال، شاخص‌ها (indexes) مکانیزم‌های کلیدی برای پشتیبانی از پرس‌وجوها در مدل‌های داده‌ای مختلف هستند.
    *   **شاخص‌های ثانویه (Secondary Indexes)**: بحث در مورد شاخص‌های ثانویه مستقیماً با پرس‌وجوها در مدل‌های داده‌ای مختلف مرتبط است، زیرا آن‌ها امکان جستجو بر اساس فیلدهای غیر از کلید اصلی را فراهم می‌کنند.
    *   **تفاوت مدل‌های رابطه‌ای و سندی**: فصل 2 تفاوت‌های اساسی بین این دو مدل را توضیح می‌دهد. فصل 3 به این تفاوت‌ها از منظر چگونگی ذخیره‌سازی داده‌ها (مثلاً ذخیره داده‌های "شرد" شده یا مسطح شده در شاخص‌های B-Tree در مقابل داده‌های سندی تو در تو در LSM-Trees) می‌پردازد.

*   **فصل 7 (Transactions)**:
    *   **دوام (Durability)**: بحث در مورد لاگ‌های write-ahead (WAL) و فرآیندهای بازیابی پس از خرابی، مستقیماً به ویژگی دوام (Durability) در تراکنش‌های ACID گره خورده است.
    *   **پردازش تک-نود (Single-node processing)**: در فصل 7، اجرای ترتیبی تراکنش‌ها (Actual Serial Execution) مورد بحث قرار گرفته است که بر فرض اینکه مجموعه داده فعال در حافظه جا می‌شود، متکی است. این با بحث پایگاه‌های داده درون-حافظه‌ای (in-memory databases) در فصل 3 همپوشانی دارد.

*   **فصل 10 و 11 (Batch Processing & Stream Processing)**:
    *   **داده‌های مشتق‌شده (Derived Data)**: مفهوم نماهای مادی‌شده (materialized views) و شاخص‌ها که در فصل 3 معرفی شده‌اند، زمینه‌ساز بحث گسترده‌تر در مورد داده‌های مشتق‌شده در بخش سوم کتاب (فصل‌های 10 و 11) است. این فصل‌ها نشان می‌دهند که چگونه عملیات تحلیلی (OLAP) از این مفاهیم برای پردازش دسته‌ای (batch processing) و جریان (stream processing) استفاده می‌کنند.
    *   **انبار داده (Data Warehouse)**: در فصل 3 مفهوم انبار داده به عنوان یک سیستم OLAP معرفی می‌شود. فصل‌های 10 و 11 به تفصیل در مورد ابزارها و تکنیک‌های پردازش داده در مقیاس بزرگ که برای پر کردن و پرس‌وجو از انبارهای داده استفاده می‌شوند، صحبت می‌کنند.

---

### **پرسش و پاسخ برای درک بهتر**

**1. سوال:** پایگاه داده‌های واقعی چگونه مسئله "پر شدن دیسک" را در سیستم‌های مبتنی بر لاگ فقط-الحاق (append-only logs) حل می‌کنند، در حالی که عملکرد نوشتن سریع آن‌ها را حفظ می‌کنند؟
**پاسخ:** سیستم‌های مبتنی بر لاگ فقط-الحاق، مانند آن‌هایی که از SSTables و LSM-Trees استفاده می‌کنند، با تقسیم لاگ به **بخش‌هایی با اندازه معین (segments)** و انجام عملیات **"فشردگی" (compaction)** روی این بخش‌ها، از پر شدن دیسک جلوگیری می‌کنند. فشردگی به معنای دور انداختن نسخه‌های قدیمی‌تر کلیدهای تکراری و نگه‌داشتن فقط جدیدترین به‌روزرسانی برای هر کلید است. این فرآیند در پس‌زمینه اجرا می‌شود و بخش‌های فشرده‌شده جدیدی را ایجاد می‌کند که از فضای دیسک کمتری استفاده می‌کنند، در حالی که نوشتن‌های جدید همچنان به انتهای بخش فعلی اضافه می‌شوند و سرعت بالای نوشتن را حفظ می‌کنند.

**2. سوال:** تفاوت‌های عملکردی اصلی بین B-Trees و LSM-Trees چیست و هر کدام برای چه نوع بارهای کاری مناسب‌ترند؟
**پاسخ:**
*   **B-Trees**: داده‌ها را به صورت **درجا (in-place)** به‌روزرسانی می‌کنند. این ویژگی منجر به **زمان پاسخ (response time) پیش‌بینی‌پذیرتر**، به خصوص در **درصد‌های بالا (higher percentiles)**، برای عملیات خواندن و نوشتن می‌شود. آن‌ها برای بارهای کاری که شامل **خواند‌ن و نوشتن مختلط (mixed read/write workloads)**، به خصوص با تعداد زیادی خواندن تصادفی و محدوده پرس‌وجو، مناسب هستند. با این حال، می‌توانند دچار **"تقویت نوشتن" (write amplification)** شوند زیرا به‌روزرسانی یک رکورد ممکن است نیاز به نوشتن مجدد کل یک صفحه (page) را داشته باشد.
*   **LSM-Trees**: داده‌ها را به صورت **فقط-الحاق (append-only)** به لاگ‌های مرتب‌شده (SSTables) می‌نویسند. این رویکرد برای بارهای کاری با **حجم بالای نوشتن (high write throughput)** بسیار کارآمد است، زیرا نوشتن‌های ترتیبی روی دیسک‌ها سریع‌تر هستند. خواندن در LSM-Trees می‌تواند شامل بررسی چندین SSTable در دیسک و Memtable در حافظه باشد، که ممکن است در برخی موارد تأخیر بیشتری داشته باشد. آن‌ها برای سناریوهایی که **مقادیر برای هر کلید مکرراً به‌روزرسانی می‌شوند (frequently updated keys)**، مانند شمارنده‌ها (counters)، مناسب هستند.

**3. سوال:** چگونه سیستم‌های ذخیره‌سازی ستونی (column-oriented storage) بهینه‌سازی‌هایی را برای بارهای کاری تحلیلی (OLAP) فراهم می‌کنند که سیستم‌های سطری (row-oriented) نمی‌توانند؟
**پاسخ:** سیستم‌های ذخیره‌سازی ستونی با ذخیره کردن تمام مقادیر یک ستون خاص در کنار هم، به جای ذخیره کردن تمام داده‌های یک ردیف در کنار هم، برای بارهای کاری تحلیلی بهینه‌سازی می‌شوند. این رویکرد چندین مزیت برای OLAP دارد:
*   **کاهش I/O دیسک**: پرس‌وجوهای تحلیلی اغلب به تعداد کمی از ستون‌ها از یک جدول بزرگ نیاز دارند. در ذخیره‌سازی ستونی، فقط ستون‌های مورد نیاز باید از دیسک خوانده شوند، که به طور قابل توجهی I/O دیسک را کاهش می‌دهد.
*   **فشردگی بهتر**: از آنجایی که داده‌های یک ستون معمولاً دارای نوع داده‌ای یکسان و الگوی مشابهی هستند، تکنیک‌های فشردگی می‌توانند بسیار مؤثرتر عمل کنند و فضای ذخیره‌سازی را کاهش دهند.
*   **بهره‌وری Cache CPU**: داده‌های فشرده و متوالی در یک ستون، به صورت کارآمدتری در کش‌های CPU قرار می‌گیرند، که منجر به سرعت پردازش بالاتر می‌شود. این بهینه‌سازی‌ها باعث می‌شوند که اسکن کردن و تجمیع حجم زیادی از داده‌ها در سیستم‌های OLAP بسیار سریع‌تر انجام شود.

---

### **نکات اصلی و مهم فصل**

*   **ساختارهای داده‌ای هسته پایگاه داده**: این فصل نشان می‌دهد که پایگاه‌های داده، چه رابطه‌ای و چه NoSQL، بر اساس اصول و ساختارهای داده‌ای مشابهی برای مدیریت داده‌ها روی دیسک کار می‌کنند. این ساختارها (مانند لاگ‌های فقط-الحاق، شاخص‌های هش، SSTables، LSM-Trees و B-Trees) نحوه ذخیره، به‌روزرسانی و بازیابی کارآمد داده‌ها را تعیین می‌کنند.
*   **اهمیت لاگ (Log)**: مفهوم لاگ به عنوان یک دنباله فقط-الحاق از عملیات، در سراسر طراحی پایگاه داده (از write-ahead logs برای دوام تا log-structured storage engines) حیاتی است.
*   **فشردگی (Compaction) به عنوان یک فرآیند کلیدی**: در سیستم‌های لاگ-محور، فشردگی یک عملیات پس‌زمینه حیاتی برای مدیریت فضای دیسک و بهبود عملکرد خواندن و نوشتن است.
*   **مدل‌سازی داده برای بار کاری (Data Modeling for Workload)**: انتخاب ساختار ذخیره‌سازی و شاخص‌گذاری مناسب بستگی زیادی به نوع بار کاری (OLTP در مقابل OLAP) و الگوهای دسترسی به داده‌ها دارد. پایگاه‌های داده‌ای که برای OLTP بهینه شده‌اند، متفاوت از پایگاه‌های داده‌ای هستند که برای OLAP طراحی شده‌اند.
*   **داده‌های مشتق‌شده (Derived Data) برای کارایی**: شاخص‌ها و نماهای مادی‌شده، مثال‌های اولیه‌ای از داده‌های مشتق‌شده هستند که برای بهینه‌سازی عملکرد پرس‌وجو با انجام کار اضافی در زمان نوشتن (پیش‌محاسبه) به وجود می‌آیند. این ایده در بخش سوم کتاب (پردازش دسته‌ای و جریان) بسیار گسترش می‌یابد.

---

### **خلاصه فصل (Chapter Summary)**

فصل 3 به جزئیات نحوه ذخیره‌سازی و بازیابی داده‌ها توسط پایگاه‌های داده می‌پردازد. این فصل با بررسی ساختارهای داده‌ای پایه مانند شاخص‌های هش و فایل‌های فقط-الحاق (logs) شروع می‌شود و به مکانیزم‌هایی مانند فشردگی (compaction) و استفاده از "سنگ قبرها" (tombstones) برای مدیریت داده‌ها و فضای دیسک می‌پردازد. سپس دو خانواده اصلی از ساختارهای شاخص‌گذاری، یعنی **LSM-Trees** (که بر اساس مفهوم ادغام لاگ‌های مرتب‌شده کار می‌کنند) و **B-Trees** (ساختار درختی رایج برای به‌روزرسانی‌های درجا) را مقایسه می‌کند.

در ادامه، فصل به تمایز حیاتی بین **سیستم‌های پردازش تراکنش آنلاین (OLTP)** که برای حجم بالای عملیات کوچک و با تأخیر پایین بهینه شده‌اند، و **سیستم‌های پردازش تحلیلی آنلاین (OLAP)** (انبارهای داده) که برای پرس‌وجوهای پیچیده روی حجم زیادی از داده‌های تاریخی استفاده می‌شوند، می‌پردازد. برای OLAP، بهینه‌سازی‌هایی مانند **ذخیره‌سازی ستونی (column-oriented storage)** و **طرح‌واره‌های ستاره‌ای (star schemas)** معرفی می‌شوند. در نهایت، مفهوم **نماهای مادی‌شده (materialized views)** به عنوان راهی برای کش کردن نتایج پرس‌وجوهای رایج و بهبود عملکرد تحلیلی مورد بحث قرار می‌گیرد. این فصل درک عمیق‌تری از نحوه کار پایگاه‌های داده در سطح پایین‌تر فراهم می‌کند و مبنایی برای بحث‌های پیچیده‌تر در فصول بعدی، به ویژه در مورد داده‌های توزیع‌شده و پردازش دسته‌ای/جریان، ایجاد می‌کند.

---

### **واژگان و اصطلاحات مهم این فصل**

در ادامه، واژگان و اصطلاحات مهمی که در فصل سوم کتاب "Designing Data-Intensive Applications" معرفی و استفاده شده‌اند، به همراه توضیح آن‌ها آورده شده است:

*   **Log (لاگ)**: یک فایل داده فقط-الحاق (append-only) که برای ذخیره تغییرات و رویدادها استفاده می‌شود. در پایگاه‌های داده کاربردهای مختلفی دارد، از جمله:
    *   **Write-Ahead Log (WAL - لاگ پیش‌نوشت)**: برای تضمین دوام (durability) تراکنش‌ها در صورت خرابی استفاده می‌شود.
    *   **Log-Structured Storage Engine**: از لاگ‌ها به عنوان فرمت اصلی ذخیره‌سازی خود استفاده می‌کند.
    *   **Replication Log (لاگ تکثیر)**: برای کپی کردن نوشتن‌ها از لیدر به فالوورها استفاده می‌شود.
    *   **Event Log (لاگ رویداد)**: می‌تواند یک جریان داده (data stream) را نمایش دهد.

*   **Compaction (فشردگی)**: عملیاتی برای حذف کلیدهای تکراری در لاگ و نگه‌داشتن فقط جدیدترین به‌روزرسانی برای هر کلید، به منظور بازپس‌گیری فضای دیسک و سازماندهی بهتر داده‌ها.

*   **Tombstone (سنگ قبر)**: یک رکورد خاص که به فایل داده اضافه می‌شود تا نشان دهد یک کلید و مقدار مرتبط با آن حذف شده است. در حین فشردگی، این رکوردها باعث حذف داده‌های مربوطه می‌شوند.

*   **SSTable (Sorted String Table - جدول رشته‌ای مرتب‌شده)**: یک دنباله مرتب‌شده از جفت‌های کلید-مقدار. پایگاه‌های داده‌ای که بر پایه ساختار لاگ-مرج (LSM-Tree) کار می‌کنند از آن‌ها به عنوان واحد ذخیره‌سازی روی دیسک استفاده می‌کنند.

*   **LSM-Tree (Log-Structured Merge-Tree - درخت ادغام لاگ-محور)**: یک ساختار داده‌ای شاخص‌گذاری که برای بهینه‌سازی بارهای کاری با حجم بالای نوشتن و با استفاده از اصول لاگ‌های فقط-الحاق و ادغام بخش‌های مرتب‌شده (SSTables) طراحی شده است.

*   **Memtable (مِمتِیبل)**: یک ساختار داده‌ای در حافظه (معمولاً درختی مانند B-Tree یا Red-Black Tree) که نوشتن‌های جدید قبل از اینکه به صورت یک SSTable به دیسک فلاش شوند، در آنجا ذخیره می‌شوند.

*   **B-Tree (بی-تری)**: رایج‌ترین ساختار داده شاخص‌گذاری در پایگاه‌های داده رابطه‌ای که داده‌ها را در صفحات با اندازه ثابت ذخیره می‌کند و برای خواندن‌ها و نوشتن‌های تصادفی کارآمد است.

*   **Clustered Index (شاخص خوشه‌ای)**: نوعی شاخص که در آن داده‌های خود رکورد مستقیماً در ساختار شاخص ذخیره می‌شوند. داده‌ها فیزیکی بر اساس ترتیب شاخص مرتب می‌شوند.

*   **Secondary Index (شاخص ثانویه)**: شاخصی که بر روی یک یا چند ستون غیر از کلید اصلی ایجاد می‌شود و امکان جستجو و بازیابی رکوردها را بر اساس آن ستون‌ها فراهم می‌کند.

*   **Covering Index (شاخص پوششی)**: یک شاخص که شامل تمام ستون‌هایی است که یک پرس‌وجو به آن‌ها نیاز دارد، به طوری که پایگاه داده نیازی به دسترسی به جدول اصلی برای بازیابی داده نداشته باشد.

*   **Full-text Search (جستجوی تمام‌متنی)**: قابلیتی برای جستجو در متن با کلمات کلیدی دلخواه، اغلب با ویژگی‌های پیشرفته مانند تطابق کلمات با املای مشابه یا مترادف‌ها.

*   **Fuzzy Index (شاخص فازی)**: شاخص‌هایی که امکان جستجو برای تطابق‌های تقریبی، مانند پیدا کردن کلمات با املای نزدیک یا خطاهای تایپی را فراهم می‌کنند.

*   **In-Memory Databases (پایگاه‌های داده درون-حافظه‌ای)**: پایگاه‌های داده‌ای که تمام یا بخش بزرگی از مجموعه داده فعال را در RAM نگهداری می‌کنند تا به تأخیر (latency) بسیار پایین و توان عملیاتی (throughput) بالا دست یابند.

*   **Transaction Processing (OLTP - پردازش تراکنش آنلاین)**: نوعی بار کاری که شامل حجم بالای عملیات کوچک، اتمیک (atomic) و با تأخیر پایین (مانند به‌روزرسانی رکوردهای فردی) است و معمولاً در سیستم‌های رو به روی کاربر استفاده می‌شود.

*   **Analytics (OLAP - پردازش تحلیلی آنلاین)**: نوعی بار کاری که شامل پرس‌وجوهای پیچیده روی حجم عظیمی از داده‌های تاریخی برای گزارش‌گیری، هوش تجاری و تحلیل‌های آماری است.

*   **Data Warehouse (انبار داده)**: یک پایگاه داده که داده‌ها از چندین سیستم OLTP مختلف در آن جمع‌آوری و برای اهداف تحلیلی آماده‌سازی شده‌اند.

*   **Star Schema (طرح‌واره ستاره‌ای)**: یک الگوی رایج برای سازماندهی داده‌ها در انبار داده، شامل یک جدول واقعیت مرکزی و جداول ابعادی متصل به آن.

*   **Fact Table (جدول واقعیت)**: در یک طرح‌واره ستاره‌ای، جدولی که رویدادهای اندازه‌گیری‌پذیر را ذخیره می‌کند (مانند فروش، کلیک‌ها)، همراه با ارجاع به جداول ابعادی.

*   **Dimension Table (جدول ابعادی)**: در یک طرح‌واره ستاره‌ای، جدولی که اطلاعات متنی مربوط به رویدادها در جدول واقعیت را فراهم می‌کند (مانند محصول، زمان، مشتری).

*   **Column-Oriented Storage (ذخیره‌سازی ستونی)**: رویکردی برای ذخیره‌سازی داده‌ها که در آن تمام مقادیر یک ستون خاص در کنار هم ذخیره می‌شوند، که برای بارهای کاری تحلیلی (OLAP) بهینه است.

*   **Materialized View (نمای مادی‌شده)**: یک کپی فیزیکی از نتایج یک پرس‌وجو که روی دیسک ذخیره می‌شود و به صورت دوره‌ای یا هنگام تغییر داده‌های زیرین، به‌روزرسانی می‌شود. این یک نوع کش برای پرس‌وجوهای پیچیده است.

*   **Derived Data (داده مشتق‌شده)**: داده‌هایی که با پردازش یا تبدیل داده‌های اصلی (Source of Truth) ایجاد می‌شوند، مانند شاخص‌ها، کش‌ها، و نماهای مادی‌شده.

*   **Skew (عدم تعادل)**: اشاره به توزیع نامتوازن بار کاری در میان پارتیشن‌ها، به طوری که برخی پارتیشن‌ها بار (درخواست‌ها یا داده‌ها) بسیار بیشتری نسبت به بقیه دارند. به آن **نقاط داغ (hot spots)** نیز گفته می‌شود.

*   **Hot Spot (نقطه داغ)**: یک پارتیشن یا گره خاص در یک سیستم توزیع‌شده که حجم کاری (درخواست‌ها یا داده‌ها) نامتناسبی را دریافت می‌کند و می‌تواند منجر به گلوگاه (bottleneck) شود.

*   **System of Record (سیستم اصلی ضبط)**: سیستمی که نسخه اصلی و معتبر داده‌ها را نگهداری می‌کند. تغییرات ابتدا در این سیستم ثبت می‌شوند و سایر مجموعه‌های داده ممکن است از آن مشتق شوند.
‌
---


</div>