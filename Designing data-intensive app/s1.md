
 <div style="
     direction: rtl;
       text-align: justify;
         font-family: 'Vazirmatn', Tahoma, sans-serif;
           font-size: 16px;
             line-height: 2;
               color: #222;
                 background-color: #fdfdfd;
                   padding: 20px;
                     border-radius: 12px;
                       border: 1px solid #ddd;
                         text-align-last: right;
                           unicode-bidi: plaintext;
                           ">        

# ترجمه کامل فصل اول  
**فصل 1: برنامه‌های قابل اطمینان، مقیاس‌پذیر و قابل نگهداری**

> اینترنت چنان خوب پیاده‌سازی شده است که اغلب مردم آن را مانند یک منبع طبیعی — همچون اقیانوس آرام — می‌بینند، نه چیزی که توسط بشر ساخته شده باشد. آخرین باری که فناوری در چنین ابعادی تا این حد بدون خطا کار کرده چه زمانی بود؟  
> — آلن کی (مصاحبه با Dr. Dobb's Journal، 2012)

امروزه بسیاری از برنامه‌ها **داده‌محور** (data-intensive) هستند، در مقابل برنامه‌های **محاسبه‌محور** (compute-intensive). توان خام CPU به‌ندرت برای این برنامه‌ها محدودیت ایجاد می‌کند — مشکلات بزرگ‌تر معمولاً در حجم داده‌ها، پیچیدگی داده‌ها و سرعت تغییر داده‌ها نهفته است.

یک برنامه داده‌محور معمولاً از بلوک‌های ساختمانی استاندارد ساخته می‌شود که قابلیت‌های متداول را فراهم می‌کنند. برای مثال، بسیاری از برنامه‌ها به موارد زیر نیاز دارند:

- ذخیره داده‌ها به شکلی که بعداً بتوان دوباره به آنها دسترسی پیدا کرد (پایگاه‌های داده)
- به‌خاطر سپردن نتایج عملیات‌های پرهزینه برای سرعت‌بخشی به خواندن (کش‌ها)
- امکان جستجوی داده‌ها با کلیدواژه یا فیلترهای مختلف (ایندکس‌های جستجو)
- ارسال پیام به فرآیند دیگر برای پردازش غیرهمزمان (پردازش جریان)
- به طور دوره‌ای پردازش حجم بزرگی از داده‌های تجمیع‌شده (پردازش دسته‌ای)

اگر این موارد بدیهی به نظر می‌رسند، به این خاطر است که این سیستم‌های داده به‌عنوان انتزاع‌هایی موفق عمل کرده‌اند: ما دائماً از آن‌ها استفاده می‌کنیم بدون آنکه زیاد به آن فکر کنیم. اکثر مهندسان زمانی که می‌خواهند برنامه‌ای بسازند، حتی به ذهن‌شان خطور نمی‌کند که یک موتور ذخیره‌سازی داده جدید از صفر بنویسند، زیرا پایگاه‌های داده برای این کار ابزارهای مناسبی هستند.

اما در واقعیت، ماجرا به این سادگی نیست. سیستم‌های پایگاه داده متعددی با خصوصیات مختلف وجود دارد، چرا که برنامه‌های مختلف نیازهای متفاوتی دارند. رویکردهای گوناگونی برای کشینگ، ساخت ایندکس جستجو و... وجود دارد. در ساخت یک برنامه، باید تشخیص دهیم که کدام ابزارها و رویکردها برای مسئله خاص ما مناسب‌ترند. ترکیب ابزارها نیز گاهی چالش‌برانگیز می‌شود وقتی کاری فراتر از توانایی یک ابزار منفرد لازم است.

این کتاب سفری است در اصول و ملاحظات عملی سیستم‌های داده و چگونگی استفاده از آن‌ها برای ساخت برنامه‌های داده‌محور. ما بررسی می‌کنیم ابزارهای مختلف چه نقاط اشتراک و چه تفاوت‌هایی دارند و چگونه به ویژگی‌های خاص‌شان دست می‌یابند.

در این فصل، ابتدا مفاهیم پایه‌ای را بررسی می‌کنیم: چه می‌خواهیم به دست آوریم؟ سیستم‌های داده قابل اطمینان، مقیاس‌پذیر و قابل نگهداری. تعریف این مفاهیم، روش‌های تفکر درباره آن‌ها و مقدماتی که برای فصول بعد نیاز داریم را بیان خواهیم کرد.

## تفکر درباره سیستم‌های داده

معمولاً به پایگاه‌های داده، صف‌ها، کش‌ها و غیره به‌عنوان دسته‌های متفاوتی از ابزارها فکر می‌کنیم. هرچند پایگاه داده و صف پیام ممکن است شباهت‌هایی سطحی داشته باشند — هر دو برای مدتی داده را ذخیره می‌کنند — اما الگوهای دسترسی متفاوتی دارند، در نتیجه ویژگی‌های عملکردی و پیاده‌سازی‌های بسیار متفاوتی نیز دارند.

پس چرا همه این ابزارها را تحت عنوان کلی «سیستم‌های داده» جمع می‌کنیم؟

در سال‌های اخیر ابزارهای متعددی برای ذخیره و پردازش داده پدید آمده‌اند که برای کاربردهای مختلف بهینه‌سازی شده‌اند و دیگر به راحتی در دسته‌بندی‌های سنتی نمی‌گنجند. برای مثال، Redis هم دیتاستور است و هم صف پیام؛ Kafka نیز صف پیام است که ویژگی‌های پایداری مانند پایگاه داده دارد. مرز میان این دسته‌ها در حال محو شدن است.

بعلاوه، بسیاری از برنامه‌ها امروزه نیازهایی چنان وسیع و متنوع دارند که یک ابزار واحد نمی‌تواند تمام نیازهای پردازشی و ذخیره‌سازی داده را پوشش دهد. بنابراین کار را به وظایفی کوچک‌تر تقسیم می‌کنند که هرکدام به طور کارآمد روی یک ابزار خاص انجام می‌شود و این ابزارهای مختلف با کد اپلیکیشن به هم متصل می‌شوند.

برای مثال، ممکن است یک لایه کش جدا (مانند Memcached) یا موتور جستجوی تمام متن (مانند Elasticsearch یا Solr) کنار پایگاه داده اصلی وجود داشته باشد. همگام‌سازی کش و ایندکس با پایگاه داده اصلی معمولاً به عهده کد اپلیکیشن است. وقتی چندین ابزار را برای ارائه سرویس ترکیب می‌کنید، شما در واقع در حال طراحی یک سیستم داده اختصاصی از اجزای عمومی هستید.

حال که شما علاوه بر توسعه‌دهنده، به نوعی طراح سیستم داده نیز هستید، سؤالات چالش‌برانگیزی مطرح می‌شود:  
چگونه اطمینان حاصل می‌کنید که داده‌ها حتی در شرایط بروز خطا نیز درست باقی می‌مانند؟  
چگونه در شرایط کاهش کارایی بخشی از سیستم، کارایی کلی را حفظ می‌کنید؟  
چگونه با افزایش بار سیستم کنار می‌آیید؟  
چه API مناسبی برای سرویس طراحی می‌کنید؟

ما در این کتاب روی سه ویژگی تمرکز می‌کنیم که تقریباً در تمام سیستم‌های نرم‌افزاری اهمیت دارند:

### قابلیت اطمینان (Reliability)
سیستم حتی در شرایط بروز خطا به کارکرد صحیح ادامه دهد (جلوگیری از بروز خطاهای سیستمی کلی، حتی در صورت وجود خطا در اجزای داخلی)

### مقیاس‌پذیری (Scalability)
با افزایش حجم داده یا بار کاری، سیستم همچنان بتواند عملکرد مطلوبی ارائه دهد

### قابلیت نگهداری (Maintainability)
در طول زمان، افراد مختلف بتوانند سیستم را درک کرده و آن را به سادگی نگهداری، گسترش و توسعه دهند.


## قابلیت اطمینان (Reliability)

همه ما به طور شهودی می‌دانیم که قابلیت اطمینان یعنی چه. برای نرم‌افزار، انتظارات متداول شامل این موارد است:

- برنامه همان کاری را انجام دهد که کاربر انتظار دارد.
- بتواند اشتباهات کاربران یا استفاده‌های غیرمنتظره را تحمل کند.
- عملکرد مناسبی برای کاربرد موردنظر داشته باشد.
- دسترسی غیرمجاز و سوءاستفاده را جلوگیری کند.

اگر تمام این موارد را تحت عنوان «عملکرد صحیح» در نظر بگیریم، آنگاه قابلیت اطمینان به معنای «ادامه عملکرد صحیح حتی در مواجهه با مشکلات» تعریف می‌شود.

مشکلاتی که ممکن است رخ دهند **خطا** (fault) نامیده می‌شوند و سیستم‌هایی که برای مقابله با خطا طراحی شده‌اند، **تحمل خطا** (fault-tolerant) یا **مقاوم** (resilient) نامیده می‌شوند.

البته واقع‌گرایانه نیست که تصور کنیم می‌توان همه خطاهای ممکن را تحمل کرد. بنابراین هدف این است که مانع شویم خطاها منجر به **شکست** (failure) شوند.

### خطاهای سخت‌افزاری

اغلب به عنوان اولین علت شکست سیستم‌ها به ذهن می‌آیند:  
خرابی دیسک، اشکالات RAM، قطع برق، قطع کابل شبکه و غیره. در مراکز داده بزرگ این اتفاقات بسیار متداول است.  
برای مقابله با این خطاها، معمولاً سخت‌افزار را **افزونگی** (redundancy) می‌دهیم:  
RAID برای دیسک، منابع تغذیه دوگانه، ژنراتورهای پشتیبان و غیره. اما این اقدامات فقط بخشی از مشکلات را رفع می‌کنند.

با رشد حجم داده‌ها و افزایش نیاز به مقیاس، حتی در صورت افزونگی سخت‌افزاری، سیستم‌ها باید بتوانند از طریق مکانیزم‌های **تحمل خطای نرم‌افزاری** نیز با از کار افتادن کل ماشین‌ها مقابله کنند.

### خطاهای نرم‌افزاری

اشکالات سیستمی که ناشی از اشکالات کدنویسی، منابع مشترک (CPU، رم، شبکه) و وابستگی به سرویس‌های دیگر هستند.  
برای مثال، باگ کرنل لینوکس هنگام «ثانیه کبیسه» در سال ۲۰۱۲ که باعث شد بسیاری از سیستم‌ها همزمان از کار بیفتند.

برخی خطاهای نرم‌افزاری تنها در شرایط خاصی رخ می‌دهند و مدت‌ها پنهان می‌مانند.

### خطاهای انسانی

اپراتورها هم انسان هستند و اشتباه می‌کنند. در بسیاری از سیستم‌های بزرگ، عامل اصلی بسیاری از قطعی‌ها، خطاهای پیکربندی انسانی هستند.

برای کاهش این خطاها:
- طراحی مناسب رابط‌ها و APIها
- ایجاد محیط‌های تست مشابه واقعی
- آزمایش جامع (تست خودکار و دستی)
- ابزارهای بازگردانی سریع از خطا
- مانیتورینگ دقیق
- آموزش مناسب تیم‌ها

### اهمیت قابلیت اطمینان

قابلیت اطمینان فقط برای نیروگاه هسته‌ای و کنترل ترافیک هوایی نیست؛ حتی در فروشگاه آنلاین کوچک هم باگ‌های نرم‌افزاری منجر به خسارات مالی و آسیب اعتباری می‌شود.  
گاهی در مراحل اولیه استارتاپ می‌توان برای کاهش هزینه‌ها از برخی جنبه‌های اطمینان صرفنظر کرد، اما باید کاملاً آگاهانه باشد.

## مقیاس‌پذیری (Scalability)

حتی اگر سیستم امروز به خوبی کار می‌کند، ممکن است با رشد بار دچار افت عملکرد شود.  
**مقیاس‌پذیری** یعنی توانایی مقابله با افزایش بار (ترافیک بیشتر، داده‌های حجیم‌تر، یا پیچیدگی بیشتر).

بحث مقیاس‌پذیری زمانی معنا دارد که بار سیستم را به درستی اندازه‌گیری کنیم. این بار می‌تواند:  
- تعداد درخواست در ثانیه  
- نرخ خواندن به نوشتن  
- تعداد کاربران همزمان  
- حجم داده  
و سایر معیارها باشد.

### مثال توییتر

- **ارسال توییت:** میانگین 4600 درخواست بر ثانیه
- **نمایش تایم‌لاین:** 300 هزار درخواست بر ثانیه

اینجا چالش مقیاس‌پذیری بیشتر در عملیات خواندن است نه نوشتن.

دو رویکرد پیاده‌سازی:

1. هنگام نمایش تایم‌لاین به‌صورت زنده داده‌ها را از دیتابیس واکشی و تجمیع کنیم.
2. هنگام ارسال توییت، برای تمام فالوورها بلافاصله کپی تولید کنیم تا خواندن سریع شود.

در نهایت ترکیبی از هر دو مدل پیاده شد: برای اکثر کاربران مدل دوم، برای افراد پرطرفدار (celebrities) مدل اول.

### توصیف عملکرد

برای توصیف عملکرد سیستم معمولاً به دو معیار توجه می‌کنیم:

- **Throughput (توان عملیاتی):** تعداد درخواست پردازش‌شده در واحد زمان
- **Response Time (زمان پاسخ):** زمان بین ارسال درخواست و دریافت پاسخ توسط کاربر

زمان پاسخ باید به‌صورت **توزیعی** (distribution) در نظر گرفته شود چون تغییرپذیری زیادی دارد.

### اهمیت درصدیلات (Percentiles)

میانگین کافی نیست؛ باید درصدیلات 50 (میانه)، 95، 99 و 99.9 را محاسبه کرد.  
مثلاً اگر p95 = 1.5s یعنی 95% درخواست‌ها زیر ۱.۵ ثانیه پاسخ داده می‌شوند.

شرکت‌هایی مانند آمازون حتی روی p99.9 حساس هستند زیرا مشتریان کلیدی ممکن است همین گروه باشند.

### دشواری بهبود تاخیر در صدک‌های بالا

بهبود پاسخ‌های کند بسیار سخت است زیرا معمولاً تحت تأثیر عوامل تصادفی خارج از کنترل (صف‌های پردازش، تأخیر شبکه، GC و غیره) هستند.

### مفهوم *Tail Latency Amplification*

وقتی یک درخواست کاربر نهایی به چندین سرویس داخلی وابسته است، کندی حتی یکی از آن سرویس‌ها می‌تواند کل درخواست را کند کند.

## رویکردهای مقابله با بار (Scaling Approaches)

راهکارها بسته به رشد بار متفاوت می‌شوند:

- **Scaling Up:** ارتقاء سخت‌افزار (پردازنده، رم، دیسک)
- **Scaling Out:** توزیع بار روی چند ماشین (shared-nothing architecture)

توزیع سیستم‌های بی‌حالت (stateless) ساده‌تر از توزیع سیستم‌های داده‌محور (stateful) است.

امروزه به دلیل افزایش ابزارهای توزیع‌شده، استفاده از سیستم‌های توزیع‌شده حتی در مقیاس‌های کوچک‌تر هم در حال گسترش است.

هیچ معماری مقیاس‌پذیر عمومی وجود ندارد؛ معماری هر سیستم باید متناسب با نوع عملیات متداول آن طراحی شود.

## قابلیت نگهداری (Maintainability)

بیشترین هزینه نرم‌افزار در طول عمر آن صرف نگهداری می‌شود:  
- رفع باگ‌ها  
- به‌روزرسانی سیستم عامل و پلتفرم‌ها  
- سازگاری با نیازهای جدید  
- بازپرداخت بدهی فنی

### سه اصل کلیدی طراحی برای نگهداری:

### ۱. قابلیت عملیات (Operability)
آسان کردن مدیریت و پایش سیستم برای تیم‌های عملیات

### ۲. سادگی (Simplicity)
کاهش پیچیدگی ذاتی سیستم برای فهم آسان مهندسان جدید (با پیچیدگی رابط کاربری اشتباه نشود)

### ۳. قابلیت توسعه (Evolvability)
امکان گسترش و تغییر راحت سیستم با توجه به نیازهای آینده

طراحی درست اولیه تا حد زیادی جلوی تبدیل شدن سیستم به «سیستم ارثی بدنام» را می‌گیرد.

## جمع‌بندی فصل

در این فصل، سه ویژگی کلیدی را معرفی کردیم که در سراسر این کتاب به آن‌ها خواهیم پرداخت:

- **قابلیت اطمینان**: سیستم حتی در شرایط خطا کارکرد صحیح داشته باشد.
- **مقیاس‌پذیری**: افزایش حجم داده و بار را بتوان با طراحی مناسب پاسخ داد.
- **قابلیت نگهداری**: سیستم در طول زمان به سادگی توسعه، نگهداری و اصلاح شود.

در فصول بعدی، لایه به لایه وارد جزییات طراحی، الگوریتم‌ها و تکنیک‌های تحقق این اهداف می‌شویم.


